<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>编辑器预览测试</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .test-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .input-area, .preview-area {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
        }
        
        .input-area h3, .preview-area h3 {
            margin-top: 0;
        }
        
        textarea {
            width: 100%;
            height: 400px;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 10px;
            font-family: 'Consolas', monospace;
            resize: vertical;
        }
        
        .preview-content {
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 15px;
            min-height: 400px;
            background-color: #fafafa;
        }
        
        /* 目录预览样式 */
        .blog-content-with-toc {
            display: grid;
            grid-template-columns: 1fr 200px;
            gap: 20px;
            align-items: start;
        }
        
        .blog-toc-preview-container {
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            font-size: 0.9em;
            position: sticky;
            top: 20px;
        }
        
        .blog-toc-preview-container h3 {
            margin: 0 0 10px 0;
            font-size: 1em;
            border-bottom: 1px solid #ddd;
            padding-bottom: 8px;
        }
        
        .toc-preview-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .toc-preview-list li {
            margin: 5px 0;
        }
        
        .toc-preview-list .toc-main-item {
            font-weight: 500;
        }
        
        .toc-preview-list .toc-sub-list {
            list-style: none;
            padding: 0;
            margin: 5px 0 0 15px;
        }
        
        .toc-preview-list .toc-sub-list li {
            margin: 3px 0;
            font-size: 0.9em;
            color: #666;
        }
        
        .blog-title {
            border-bottom: 2px solid #ddd;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <h1>📝 编辑器预览功能测试</h1>
    
    <div class="test-container">
        <div class="input-area">
            <h3>输入区域</h3>
            <label>标题：</label>
            <input type="text" id="title-input" placeholder="输入文章标题..." value="【技术分享】测试文章">
            <br><br>
            <label>内容：</label>
            <textarea id="content-input" placeholder="输入Markdown内容...">## 介绍

这是文章的介绍部分。

## 主要功能

### 编辑器功能
- 实时预览
- 目录生成
- 自动保存

### 发布功能
- 自动封面生成
- 博客列表更新

## 使用方法

### 基本操作
1. 输入标题
2. 编写内容
3. 发布文章

### 高级功能
- 快捷键支持
- 草稿管理

## 总结

这是一个功能完整的博客编辑器。</textarea>
        </div>
        
        <div class="preview-area">
            <h3>预览区域</h3>
            <div id="preview-content" class="preview-content">
                <p>在左侧输入内容，这里将显示预览...</p>
            </div>
        </div>
    </div>

    <script>
        // 复制编辑器的核心预览功能
        class PreviewTester {
            constructor() {
                this.titleInput = document.getElementById('title-input');
                this.contentInput = document.getElementById('content-input');
                this.previewArea = document.getElementById('preview-content');
                
                this.bindEvents();
                this.updatePreview(); // 初始预览
            }
            
            bindEvents() {
                this.titleInput.addEventListener('input', () => this.updatePreview());
                this.contentInput.addEventListener('input', () => this.updatePreview());
            }
            
            updatePreview() {
                const title = this.titleInput.value;
                const content = this.contentInput.value;
                
                if (!title && !content) {
                    this.previewArea.innerHTML = '<p>在左侧输入内容，这里将显示预览...</p>';
                    return;
                }
                
                const previewHtml = this.generatePreviewHtml(title, content);
                this.previewArea.innerHTML = previewHtml;
            }
            
            generatePreviewHtml(title, content) {
                let html = '<div class="blog-preview-container">';
                
                if (title) {
                    html += `<h1 class="blog-title">${this.escapeHtml(title)}</h1>`;
                }
                
                if (content) {
                    const parsedContent = this.parseMarkdown(content);
                    const toc = this.generateTableOfContents(content);
                    
                    if (toc.length > 0) {
                        html += '<div class="blog-content-with-toc">';
                        html += '<div class="blog-main-content">';
                        html += parsedContent;
                        html += '</div>';
                        html += '<div class="blog-toc-preview">';
                        html += this.generateTocHtml(toc);
                        html += '</div>';
                        html += '</div>';
                    } else {
                        html += '<div class="blog-main-content">';
                        html += parsedContent;
                        html += '</div>';
                    }
                }
                
                html += '</div>';
                return html;
            }
            
            generateTableOfContents(content) {
                const lines = content.split('\n');
                const headings = [];

                lines.forEach((line, index) => {
                    const trimmedLine = line.trim();
                    const match = trimmedLine.match(/^(#{1,6})\s+(.+)$/);
                    if (match) {
                        const level = match[1].length;
                        const title = match[2].trim();
                        const anchor = this.generateAnchor(title, headings.length);
                        headings.push({ level, title, anchor });
                    }
                });

                return headings;
            }
            
            generateAnchor(title, index) {
                let anchor = title
                    .replace(/[【】\[\]]/g, '')
                    .replace(/[^\u4e00-\u9fa5a-zA-Z0-9\s]/g, '')
                    .trim()
                    .replace(/\s+/g, '-')
                    .toLowerCase();

                if (!anchor || anchor.length < 2) {
                    anchor = `heading-${index}`;
                }

                return anchor;
            }
            
            generateTocHtml(tableOfContents) {
                if (!tableOfContents || tableOfContents.length === 0) {
                    return '';
                }

                let html = '<div class="blog-toc-preview-container">\\n';
                html += '<h3>目录预览</h3>\\n';
                html += '<ul class="toc-preview-list">\\n';

                let currentMainItem = null;
                let subItems = [];

                tableOfContents.forEach((item, index) => {
                    if (item.level <= 2) {
                        if (currentMainItem && subItems.length > 0) {
                            html += `<li class="toc-main-item collapsible">\\n`;
                            html += `  <a href="#${currentMainItem.anchor}">${currentMainItem.title}</a>\\n`;
                            html += '  <ul class="toc-sub-list">\\n';
                            
                            subItems.forEach(subItem => {
                                html += `    <li><a href="#${subItem.anchor}">${subItem.title}</a></li>\\n`;
                            });
                            
                            html += '  </ul>\\n';
                            html += '</li>\\n';
                        } else if (currentMainItem) {
                            html += `<li class="toc-main-item"><a href="#${currentMainItem.anchor}">${currentMainItem.title}</a></li>\\n`;
                        }

                        currentMainItem = item;
                        subItems = [];
                    } else if (item.level === 3 && currentMainItem) {
                        subItems.push(item);
                    }
                });

                if (currentMainItem && subItems.length > 0) {
                    html += `<li class="toc-main-item collapsible">\\n`;
                    html += `  <a href="#${currentMainItem.anchor}">${currentMainItem.title}</a>\\n`;
                    html += '  <ul class="toc-sub-list">\\n';
                    
                    subItems.forEach(subItem => {
                        html += `    <li><a href="#${subItem.anchor}">${subItem.title}</a></li>\\n`;
                    });
                    
                    html += '  </ul>\\n';
                    html += '</li>\\n';
                } else if (currentMainItem) {
                    html += `<li class="toc-main-item"><a href="#${currentMainItem.anchor}">${currentMainItem.title}</a></li>\\n`;
                }

                html += '</ul>\\n';
                html += '</div>';

                return html;
            }
            
            parseMarkdown(text) {
                const toc = this.generateTableOfContents(text);
                const anchorMap = {};
                toc.forEach(item => {
                    anchorMap[item.title] = item.anchor;
                });

                let html = text;
                
                // 处理标题并添加锚点
                html = html.replace(/^#### (.*$)/gim, (match, title) => {
                    const anchor = anchorMap[title] || this.generateAnchor(title, 0);
                    return `<h4 id="${anchor}">${title}</h4>`;
                });
                
                html = html.replace(/^### (.*$)/gim, (match, title) => {
                    const anchor = anchorMap[title] || this.generateAnchor(title, 0);
                    return `<h3 id="${anchor}">${title}</h3>`;
                });
                
                html = html.replace(/^## (.*$)/gim, (match, title) => {
                    const anchor = anchorMap[title] || this.generateAnchor(title, 0);
                    return `<h2 id="${anchor}">${title}</h2>`;
                });
                
                html = html.replace(/^# (.*$)/gim, (match, title) => {
                    const anchor = anchorMap[title] || this.generateAnchor(title, 0);
                    return `<h1 id="${anchor}">${title}</h1>`;
                });

                // 其他Markdown语法
                html = html
                    // 粗体和斜体
                    .replace(/\*\*(.*?)\*\*/gim, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/gim, '<em>$1</em>')
                    // 代码
                    .replace(/`([^`]+)`/gim, '<code>$1</code>')
                    // 链接
                    .replace(/\[([^\]]+)\]\(([^)]+)\)/gim, '<a href="$2" target="_blank">$1</a>')
                    // 列表项
                    .replace(/^- (.*$)/gim, '<li>$1</li>')
                    // 段落处理
                    .split('\n\n')
                    .map(paragraph => {
                        paragraph = paragraph.trim();
                        if (!paragraph) return '';
                        
                        // 如果已经是HTML标签，直接返回
                        if (paragraph.match(/^<(h[1-6]|ul|li|div)/)) {
                            return paragraph;
                        }
                        
                        // 处理列表项
                        if (paragraph.includes('<li>')) {
                            return `<ul>${paragraph}</ul>`;
                        }
                        
                        // 否则包装为段落
                        return `<p>${paragraph.replace(/\n/g, '<br>')}</p>`;
                    })
                    .filter(p => p)
                    .join('\n');

                return html;
            }
            
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        }
        
        // 页面加载后初始化
        document.addEventListener('DOMContentLoaded', () => {
            new PreviewTester();
        });
    </script>
</body>
</html>